#!/usr/bin/env python3

import argparse
import json
import logging
import os
import sys

from graphqlclient import GraphQLClient
from typing import Dict

from miniworld import Constants
from miniworld.util import CliUtil
from miniworld.util.CliUtil import rpc_parser

logging.basicConfig()
log = logging.getLogger()


class Action:
    '''
    Models an action that is associated with a argparse parser.
    The class behaves like a function, but provides custom initialization.

    Attributes
    ----------
    connection : xmlrpc.ServerProxy
    address : str
        The RPC connection address string.
    '''

    def __init__(self, fun):
        self.fun = fun

    def __call__(self, *args, **kwargs):
        # TODO: adopt get_connection logic from mwcli.rpc
        self.client = GraphQLClient('http://127.0.0.1:5000/graphql')
        client_execute = self.client.execute

        def execute_graphql(query, *args, **kwargs) -> Dict:
            """ Monkey-patch execute method of GraphQLClient. """
            print('executing graphql: {}, variables: {}'.format(query, kwargs.get('variables')), file=sys.stderr)
            res_json = client_execute(query, *args, **kwargs)
            res = json.loads(res_json)
            if res.get('errors') is not None:
                print('graphql errors: {}'.format(res['errors']), file=sys.stderr)
                sys.exit(1)
            print(res_json, file=sys.stderr)
            return res

        self.client.execute = execute_graphql

        # supply ActionSubClass to the method
        return self.fun(self, *args, **kwargs)


def new_action_decorator(fun):
    '''
    Models an Action class as method there the self paramter is supplied as first argument.

    Create
    Parameters
    ----------
    fun

    Returns
    -------
    ActionSubClass
    '''

    return Action(fun)


#################################################
### info
#################################################

@new_action_decorator
def action_info_addr(self, args):
    res = self.connection.get_distributed_address_mapping()
    if args.node_id:
        res = json.loads(res)[args.node_id]

    print(res)


@new_action_decorator
def action_info_server(self, args):
    node_id = args.node_id
    if node_id:
        return self.connection.get_server_for_node(node_id)
    else:
        print(self.connection.get_distributed_node_mapping())


@new_action_decorator
def action_info_connections(self, args):
    print(self.connection.get_connections())


@new_action_decorator
def action_info_links(self, args):
    print(self.connection.get_links(args.include_interfaces))


@new_action_decorator
def action_info_distances(self, args):
    print(self.connection.get_distance_matrix())


@new_action_decorator
def action_info_scenario(self, args):
    print(self.connection.get_scenario())


# @new_action_decorator
# def action_info_shell_vars(self, args):
#     print self.connection.get_shell_variables(args.node_id)

#################################################
### ping
#################################################

@new_action_decorator
def action_ping(self, args):
    res = self.client.execute('''
    query {
        ping
    } 
    ''')
    print(res)


#################################################
### logs
#################################################

@new_action_decorator
def action_logs_boot(self, args):
    print(json.loads(self.connection.node_get_qemu_boot_log(args.node_id)))


@new_action_decorator
def action_start(self, args):
    scenario_config, _, scenario_config_json = CliUtil.parse_scenario_config(args.scenario_config, args.custom_scenario)

    query = '''
mutation MyMutations($scenario_config: String) {
    scenarioStart(scenarioConfig: $scenario_config) {
        scenarioConfig
    }
}
 '''
    self.client.execute(query, variables={'scenario_config': scenario_config_json})


@new_action_decorator
def action_stop(self, args):
    query = '''
mutation MyMutations {
    scenarioAbort {status}
}
    '''
    self.client.execute(query)


@new_action_decorator
def action_step(self, args):
    query = '''
mutation {
 scenarioStep(steps:1) {
    steps
 }
}
'''
    self.client.execute(query)


@new_action_decorator
def action_exec(self, args):
    query = '''
mutation ($node_id: Int, $cmd: String, $validate: Boolean, $timeout: Float){
   nodeExecuteCommand(id: $node_id, cmd: $cmd, validate: $validate, timeout: $timeout) {
       result
   }
}
'''
    variables = {
        'node_id': args.node_id,
        'cmd': args.cmd,
    }
    if args.timeout is not None:
        variables['timeout'] = args.timeout
    if args.validate is not None:
        variables['validate'] = args.validate
    res = self.client.execute(query, variables)
    print(res['data']['nodeExecuteCommand']['result'])


def action_shell(args):
    path = os.path.join(Constants.PATH_TMP, 'qemu_{}.sock'.format(args.node_id))

    input_device = None
    if os.isatty(sys.stdout.fileno()):
        try:
            input_device = os.ttyname(sys.stdin.fileno())  # type: str
        # we get this error on a non-tty device for `ttyname`
        except OSError as e:
            if not e.errno == 0:
                raise
            print('not connected to a tty', file=sys.stderr)
    if not input_device:
        input_device = '/dev/stdin'

    print('redirecting between "{}" and "{}"'.format(path, input_device), file=sys.stderr)
    print('you may need to press enter to see the shell prompt ', file=sys.stderr)
    print('detach with CTRL-D', file=sys.stderr)
    os.system('socat {},raw,echo=0,escape=0x4 UNIX-Connect:{}'.format(input_device, path))
    # subprocess.Popen('socat {},raw,echo=0,escape=0x4 UNIX-Connect:{}'.format(input_device, path).split(' '), stdin=sys.stdin,
    #                 stdout=sys.stdout, stderr=sys.stderr, shell=True)


def main(args=None):
    ACTION_START = "start"
    ACTION_STOP = "stop"
    ACTION_STEP = "step"

    ACTION_LOGS = "logs"
    ACTION_LOGS_BOOT = "boot"

    ACTION_EXEC = "exec"
    ACTION_SHELL = "shell"
    # ACTION_EXEC_SINGLE = "execs"

    ACTION_PING = "ping"

    ACTION_INFO = "info"
    # ACTION_INFO_SHELL_VARS = "shell_vars"
    ACTION_INFO_ADDR = "addr"
    ACTION_INFO_SERVER = "server"
    ACTION_INFO_CONNECTIONS = "connections"
    ACTION_INFO_DISTANCES = "distances"
    ACTION_INFO_LINKS = "links"
    ACTION_INFO_SCENARIO = "scenario"

    root_parser = argparse.ArgumentParser(description='%s CLI' % Constants.PROJECT_NAME, parents=[rpc_parser],
                                          conflict_handler='resolve')
    root_parser.add_argument("--no-check", "-nc", action="store_true",
                             help="Do not check for exceptions in the RunLoop first")
    root_parser.add_argument("--distributed", action="store_true", help="MiniWorld is run in the distributed mode.")

    subparser = root_parser.add_subparsers(help='Subcommands')

    def add_node_id_arg_optional(parser):
        parser.add_argument("--node-id", "-ni", help="The node id")

    def add_node_id_arg_positional(parser):
        parser.add_argument("node_id", help="The node id")

    def add_include_interfaces_optional(parser):
        parser.add_argument("--include-interfaces", "-ii", action="store_true",
                            help="Show between which interfaces the connections are")

    def create_subparsers(subparser):
        info_parser = subparser.add_parser(ACTION_INFO)
        logs_parser = subparser.add_parser(ACTION_LOGS)
        start_parser = subparser.add_parser(ACTION_START)
        stop_parser = subparser.add_parser(ACTION_STOP)
        step_parser = subparser.add_parser(ACTION_STEP)
        exec_parser = subparser.add_parser(ACTION_EXEC)
        shell_parser = subparser.add_parser(ACTION_SHELL)
        # execs_parser = subparser.add_parser(ACTION_EXEC_SINGLE)
        ping_parser = subparser.add_parser(ACTION_PING)

        def create_info_parsers():
            info_subparser = info_parser.add_subparsers(help='Info Subcommands')

            # addr parser
            info_addr_parser = info_subparser.add_parser(ACTION_INFO_ADDR)
            add_node_id_arg_optional(info_addr_parser)
            info_addr_parser.set_defaults(func=action_info_addr)

            # server parser
            info_server_parser = info_subparser.add_parser(ACTION_INFO_SERVER)
            add_node_id_arg_optional(info_server_parser)
            info_server_parser.set_defaults(func=action_info_server)

            # connections parser
            connections_parser = info_subparser.add_parser(ACTION_INFO_CONNECTIONS)
            add_include_interfaces_optional(connections_parser)
            connections_parser.set_defaults(func=action_info_connections)

            # links parser
            link_parser = info_subparser.add_parser(ACTION_INFO_LINKS)
            add_include_interfaces_optional(link_parser)
            link_parser.set_defaults(func=action_info_links)

            # distances parser
            distances_parser = info_subparser.add_parser(ACTION_INFO_DISTANCES)
            distances_parser.set_defaults(func=action_info_distances)

            # shell variables
            # shell_vars_parser = info_subparser.add_parser(ACTION_INFO_SHELL_VARS)
            # add_node_id_arg_optional(shell_vars_parser)
            # shell_vars_parser.set_defaults(func=action_info_shell_vars)

            # scenario parser
            scenario_parser = info_subparser.add_parser(ACTION_INFO_SCENARIO)
            scenario_parser.set_defaults(func=action_info_scenario)

        def create_log_parsers():
            log_subparser = logs_parser.add_subparsers(help='Info Subcommands')
            boot_parser = log_subparser.add_parser(ACTION_LOGS_BOOT)
            add_node_id_arg_positional(boot_parser)
            boot_parser.set_defaults(func=action_logs_boot)

        def create_start_parsers():
            # start_subparser = logs_parser.add_subparsers(help='Info Subcommands')
            start_parser.add_argument("-cs", "--custom-scenario", help="Overrite settings in the senario file")
            start_parser.add_argument("-cc", "--custom-config", help="Overrite settings in the config file")
            start_parser.add_argument("-as", "--auto-stepping", action="store_true", default=False,
                                      help="If auto stepping is enabled, each concrete time interval a step is triggered. The default value is: %(default)s. If explicitly disabled, you have step manually.")
            start_parser.add_argument("-p", "--progress", action="store_true", default=False,
                                      help="Show the progress via the CLI.")
            start_parser.add_argument("scenario_config",
                                      help="The scenario config (.json) that describes the scenario you want to start.")
            start_parser.add_argument("-fs", "--force-snapshot-boot", default=False, action="store_true",
                                      help="Use the snapshot boot and disable the internal scenario changed check.")

            start_parser.set_defaults(func=action_start)

        def create_stop_parsers():
            stop_parser.set_defaults(func=action_stop)

        def create_step_parsers():
            step_parser.add_argument("steps", nargs='?', default=1,
                                     help="The amount of steps you want to do. Default is: %(default)s")
            step_parser.set_defaults(func=action_step)

        def create_exec_parsers():
            add_node_id_arg_optional(exec_parser)
            exec_parser.add_argument("cmd", help="The command to be executed on the node")
            exec_parser.add_argument("-v", "--validate", action="store_true", default=False,
                                     help="Validate the return code of the command. Default is: %(default)s")
            exec_parser.add_argument("-t", "--timeout", default=5,
                                     help="Time to wait for the command to complete. Default is: %(default)s")
            exec_parser.set_defaults(func=action_exec)

        def create_shell_parsers():
            add_node_id_arg_positional(shell_parser)
            shell_parser.set_defaults(func=action_shell)

        # def create_execs_parsers():
        #     add_node_id_arg_optional(execs_parser)
        #     execs_parser.add_argument("cmds", nargs="+", help="The command to be executed on the node")
        #     execs_parser.add_argument("-v", "--validate", action="store_true", default=False,
        #                               help="Validate the return code of the command. Default is: %(default)s")
        #     execs_parser.set_defaults(func=lambda *args: action_exec(*args, single=True))

        def create_ping_parsers():
            # ping parser
            ping_parser.set_defaults(func=action_ping)

        create_start_parsers()
        create_stop_parsers()
        create_exec_parsers()
        create_shell_parsers()
        # create_execs_parsers()
        create_step_parsers()
        create_info_parsers()
        create_log_parsers()
        create_ping_parsers()

        return [info_parser, logs_parser]

    # Config.set_global_config(Config.PATH_GLOBAL_CONFIG)
    create_subparsers(subparser)

    args = root_parser.parse_args()
    print("parser args: %s" % args, file=sys.stderr)

    # give the actions the option to print themselves to stdout
    if hasattr(args, 'func'):
        res = args.func(args)
        # but if a value is returned, print it here
        if res:
            print(json.dumps(res, indent=4))


if __name__ == '__main__':
    main()
