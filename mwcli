#!/usr/bin/env python3

import argparse
import json
import logging
import os
import sys

from graphqlclient import GraphQLClient

from miniworld import Constants
from miniworld.util import CliUtil
from miniworld.util.CliUtil import rpc_parser

logging.basicConfig()
log = logging.getLogger()


class Action:
    '''
    Models an action that is associated with a argparse parser.
    The class behaves like a function, but provides custom initialization.

    Attributes
    ----------
    connection : xmlrpc.ServerProxy
    address : str
        The RPC connection address string.
    '''

    def __init__(self, fun):
        self.fun = fun

    def __call__(self, *args, **kwargs):
        # TODO: adopt get_connection logic from mwcli.rpc
        self.client = GraphQLClient('http://127.0.0.1:5000/graphql')
        client_execute = self.client.execute

        def execute_graphql(query, *args, **kwargs):
            """ Monkey-patch execute method of GraphQLClient. """
            print('executing graphql: {}'.format(query), file=sys.stderr)
            res_json = client_execute(query, *args, **kwargs)
            res = json.loads(res_json)
            if res.get('errors') is not None:
                print('graphql errors: {}'.format(res['errors']), file=sys.stderr)
                sys.exit(1)
            print(res_json)

        self.client.execute = execute_graphql

        # supply ActionSubClass to the method
        return self.fun(self, *args, **kwargs)


def new_action_decorator(fun):
    '''
    Models an Action class as method there the self paramter is supplied as first argument.

    Create
    Parameters
    ----------
    fun

    Returns
    -------
    ActionSubClass
    '''

    return Action(fun)


#################################################
### info
#################################################

@new_action_decorator
def action_info_addr(self, args):
    res = self.connection.get_distributed_address_mapping()
    if args.node_id:
        res = json.loads(res)[args.node_id]

    print(res)


@new_action_decorator
def action_info_server(self, args):
    node_id = args.node_id
    if node_id:
        return self.connection.get_server_for_node(node_id)
    else:
        print(self.connection.get_distributed_node_mapping())


@new_action_decorator
def action_info_connections(self, args):
    print(self.connection.get_connections())


@new_action_decorator
def action_info_links(self, args):
    print(self.connection.get_links(args.include_interfaces))


@new_action_decorator
def action_info_distances(self, args):
    print(self.connection.get_distance_matrix())


@new_action_decorator
def action_info_scenario(self, args):
    print(self.connection.get_scenario())


# @new_action_decorator
# def action_info_shell_vars(self, args):
#     print self.connection.get_shell_variables(args.node_id)

#################################################
### ping
#################################################

@new_action_decorator
def action_ping(self, args):
    res = self.client.execute('''
    query {
        ping
    } 
    ''')
    print(res)


#################################################
### logs
#################################################

@new_action_decorator
def action_logs_boot(self, args):
    print(json.loads(self.connection.node_get_qemu_boot_log(args.node_id)))


@new_action_decorator
def action_start(self, args):
    scenario_config, _, scenario_config_json = CliUtil.parse_scenario_config(args.scenario_config, args.custom_scenario)

    query = '''
mutation MyMutations($scenario_config: String) {
    scenarioStart(scenarioConfig: $scenario_config) {
        scenarioConfig
    }
}
 '''
    self.client.execute(query, variables={'scenario_config': scenario_config_json})


@new_action_decorator
def action_stop(self, args):
    query = '''
mutation MyMutations {
    scenarioAbort {status}
}
    '''
    self.client.execute(query)


@new_action_decorator
def action_step(self, args):
    query = '''
 mutation {
     scenarioStep(steps:1) {
        steps
     }
 }
 '''
    self.client.execute(query)


@new_action_decorator
def action_exec(self, args, single=True):
    # TODO: we need to print deserialized json here due to the rpc server hack
    if not hasattr(args, "node_id"):
        node_id = None
    else:
        node_id = args.node_id

    cmd = args.cmd

    if not args.distributed:
        print(json.loads(self.connection.exec_node_cmd(cmd, node_id, args.validate, args.timeout)))
    else:
        if node_id is not None:
            # only switch to the rpc server which holds the node
            self.connection = self.get_connection_server(node_id=node_id, is_distributed=args.distributed)
            print(json.loads(self.connection.exec_node_cmd(cmd, node_id, args.validate, args.timeout)))
        else:
            for server_id in json.loads(self.connection.get_distributed_address_mapping()):

                # only switch to the rpc server which holds the node
                print("\nServer %s >>>" % server_id)
                self.connection = self.get_connection_server(server_id=server_id, is_distributed=args.distributed)
                result = json.loads(self.connection.exec_node_cmd(cmd, node_id, args.validate, args.timeout))
                for _node_id, output in result.items():
                    print("\nNode %s >>>" % _node_id)
                    print(output)


def action_shell(args):
    path = os.path.join(Constants.PATH_TMP, 'qemu_{}.sock'.format(args.node_id))

    input_device = None
    if os.isatty(sys.stdout.fileno()):
        try:
            input_device = os.ttyname(sys.stdin.fileno())  # type: str
        # we get this error on a non-tty device for `ttyname`
        except OSError as e:
            if not e.errno == 0:
                raise
            print('not connected to a tty', file=sys.stderr)
    if not input_device:
        input_device = '/dev/stdin'

    print('redirecting between "{}" and "{}"'.format(path, input_device), file=sys.stderr)
    print('you may need to press enter to see the shell prompt ', file=sys.stderr)
    print('detach with CTRL-D', file=sys.stderr)
    os.system('socat {},raw,echo=0,escape=0x4 UNIX-Connect:{}'.format(input_device, path))
    # subprocess.Popen('socat {},raw,echo=0,escape=0x4 UNIX-Connect:{}'.format(input_device, path).split(' '), stdin=sys.stdin,
    #                 stdout=sys.stdout, stderr=sys.stderr, shell=True)


def main(args=None):
    ACTION_START = "start"
    ACTION_STOP = "stop"
    ACTION_STEP = "step"

    ACTION_LOGS = "logs"
    ACTION_LOGS_BOOT = "boot"

    ACTION_EXEC = "exec"
    ACTION_SHELL = "shell"
    # ACTION_EXEC_SINGLE = "execs"

    ACTION_PING = "ping"

    ACTION_INFO = "info"
    # ACTION_INFO_SHELL_VARS = "shell_vars"
    ACTION_INFO_ADDR = "addr"
    ACTION_INFO_SERVER = "server"
    ACTION_INFO_CONNECTIONS = "connections"
    ACTION_INFO_DISTANCES = "distances"
    ACTION_INFO_LINKS = "links"
    ACTION_INFO_SCENARIO = "scenario"

    root_parser = argparse.ArgumentParser(description='%s CLI' % Constants.PROJECT_NAME, parents=[rpc_parser],
                                          conflict_handler='resolve')
    root_parser.add_argument("--no-check", "-nc", action="store_true",
                             help="Do not check for exceptions in the RunLoop first")
    root_parser.add_argument("--distributed", action="store_true", help="MiniWorld is run in the distributed mode.")

    subparser = root_parser.add_subparsers(help='Subcommands')

    def add_node_id_arg_optional(parser):
        parser.add_argument("--node-id", "-ni", help="The node id")

    def add_node_id_arg_positional(parser):
        parser.add_argument("node_id", help="The node id")

    def add_include_interfaces_optional(parser):
        parser.add_argument("--include-interfaces", "-ii", action="store_true",
                            help="Show between which interfaces the connections are")

    def create_subparsers(subparser):
        info_parser = subparser.add_parser(ACTION_INFO)
        logs_parser = subparser.add_parser(ACTION_LOGS)
        start_parser = subparser.add_parser(ACTION_START)
        stop_parser = subparser.add_parser(ACTION_STOP)
        step_parser = subparser.add_parser(ACTION_STEP)
        exec_parser = subparser.add_parser(ACTION_EXEC)
        shell_parser = subparser.add_parser(ACTION_SHELL)
        # execs_parser = subparser.add_parser(ACTION_EXEC_SINGLE)
        ping_parser = subparser.add_parser(ACTION_PING)

        def create_info_parsers():
            info_subparser = info_parser.add_subparsers(help='Info Subcommands')

            # addr parser
            info_addr_parser = info_subparser.add_parser(ACTION_INFO_ADDR)
            add_node_id_arg_optional(info_addr_parser)
            info_addr_parser.set_defaults(func=action_info_addr)

            # server parser
            info_server_parser = info_subparser.add_parser(ACTION_INFO_SERVER)
            add_node_id_arg_optional(info_server_parser)
            info_server_parser.set_defaults(func=action_info_server)

            # connections parser
            connections_parser = info_subparser.add_parser(ACTION_INFO_CONNECTIONS)
            add_include_interfaces_optional(connections_parser)
            connections_parser.set_defaults(func=action_info_connections)

            # links parser
            link_parser = info_subparser.add_parser(ACTION_INFO_LINKS)
            add_include_interfaces_optional(link_parser)
            link_parser.set_defaults(func=action_info_links)

            # distances parser
            distances_parser = info_subparser.add_parser(ACTION_INFO_DISTANCES)
            distances_parser.set_defaults(func=action_info_distances)

            # shell variables
            # shell_vars_parser = info_subparser.add_parser(ACTION_INFO_SHELL_VARS)
            # add_node_id_arg_optional(shell_vars_parser)
            # shell_vars_parser.set_defaults(func=action_info_shell_vars)

            # scenario parser
            scenario_parser = info_subparser.add_parser(ACTION_INFO_SCENARIO)
            scenario_parser.set_defaults(func=action_info_scenario)

        def create_log_parsers():
            log_subparser = logs_parser.add_subparsers(help='Info Subcommands')
            boot_parser = log_subparser.add_parser(ACTION_LOGS_BOOT)
            add_node_id_arg_positional(boot_parser)
            boot_parser.set_defaults(func=action_logs_boot)

        def create_start_parsers():
            # start_subparser = logs_parser.add_subparsers(help='Info Subcommands')
            start_parser.add_argument("-cs", "--custom-scenario", help="Overrite settings in the senario file")
            start_parser.add_argument("-cc", "--custom-config", help="Overrite settings in the config file")
            start_parser.add_argument("-as", "--auto-stepping", action="store_true", default=False,
                                      help="If auto stepping is enabled, each concrete time interval a step is triggered. The default value is: %(default)s. If explicitly disabled, you have step manually.")
            start_parser.add_argument("-p", "--progress", action="store_true", default=False,
                                      help="Show the progress via the CLI.")
            start_parser.add_argument("scenario_config",
                                      help="The scenario config (.json) that describes the scenario you want to start.")
            start_parser.add_argument("-fs", "--force-snapshot-boot", default=False, action="store_true",
                                      help="Use the snapshot boot and disable the internal scenario changed check.")

            start_parser.set_defaults(func=action_start)

        def create_stop_parsers():
            stop_parser.set_defaults(func=action_stop)

        def create_step_parsers():
            step_parser.add_argument("steps", nargs='?', default=1,
                                     help="The amount of steps you want to do. Default is: %(default)s")
            step_parser.set_defaults(func=action_step)

        def create_exec_parsers():
            add_node_id_arg_optional(exec_parser)
            exec_parser.add_argument("cmd", help="The command to be executed on the node")
            exec_parser.add_argument("-v", "--validate", action="store_true", default=False,
                                     help="Validate the return code of the command. Default is: %(default)s")
            exec_parser.add_argument("-t", "--timeout", default=5,
                                     help="Time to wait for the command to complete. Default is: %(default)s")
            exec_parser.set_defaults(func=action_exec)

        def create_shell_parsers():
            add_node_id_arg_positional(shell_parser)
            shell_parser.set_defaults(func=action_shell)

        # def create_execs_parsers():
        #     add_node_id_arg_optional(execs_parser)
        #     execs_parser.add_argument("cmds", nargs="+", help="The command to be executed on the node")
        #     execs_parser.add_argument("-v", "--validate", action="store_true", default=False,
        #                               help="Validate the return code of the command. Default is: %(default)s")
        #     execs_parser.set_defaults(func=lambda *args: action_exec(*args, single=True))

        def create_ping_parsers():
            # ping parser
            ping_parser.set_defaults(func=action_ping)

        create_start_parsers()
        create_stop_parsers()
        create_exec_parsers()
        create_shell_parsers()
        # create_execs_parsers()
        create_step_parsers()
        create_info_parsers()
        create_log_parsers()
        create_ping_parsers()

        return [info_parser, logs_parser]

    # Config.set_global_config(Config.PATH_GLOBAL_CONFIG)
    create_subparsers(subparser)

    args = root_parser.parse_args()
    print("parser args: %s" % args, file=sys.stderr)

    # give the actions the option to print themselves to stdout
    if hasattr(args, 'func'):
        res = args.func(args)
        # but if a value is returned, print it here
        if res:
            print(json.dumps(res, indent=4))


if __name__ == '__main__':
    main()
